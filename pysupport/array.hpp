/**
 * Copyright (c) 2019 Melown Technologies SE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * *  Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Code based on Boost's boost/python/suite/indexing/vector_indexing_suite.hpp
 *
 * (C) Copyright Joel de Guzman 2003.
 * Distributed under the Boost Software License, Version 1.0.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef pysupport_array_hpp_included_
#define pysupport_array_hpp_included_

#include <array>
#include <boost/python/suite/indexing/indexing_suite.hpp>
#include <boost/python/suite/indexing/container_utils.hpp>
#include <boost/python/iterator.hpp>

namespace pysupport {

// fwd
template <class Container, bool NoProxy, class DerivedPolicies>
class array_indexing_suite;

namespace detail {
template <class Container, bool NoProxy>
class final_vector_derived_policies
    : public array_indexing_suite<Container, NoProxy
                                  , final_vector_derived_policies
                                  <Container, NoProxy>>
{};

} // namespace detail

template <class Container, bool NoProxy = false,  class DerivedPolicies
          = detail::final_vector_derived_policies<Container, NoProxy> >
class array_indexing_suite
    : public boost::python::indexing_suite<Container, DerivedPolicies, NoProxy>
{
public:
    typedef typename Container::value_type data_type;
    typedef typename Container::value_type key_type;
    typedef typename Container::size_type index_type;
    typedef typename Container::size_type size_type;
    typedef typename Container::difference_type difference_type;

    static typename boost::mpl::if_<boost::is_class<data_type>
                                    , data_type&
                                    , data_type
                                    >::type
    get_item(Container &container, index_type i) {
        return container[i];
    }

    static boost::python::object get_slice(Container &container
                                            , index_type from
                                            , index_type to)
    {
        if (from > to) { return boost::python::object(Container()); }

        boost::python::list list;
        while (from != to) { list.append(container[from++]); }
        return list;
    }

    static void set_item(Container &container, index_type i
                         , const data_type &v)
    {
        container[i] = v;
    }

    static void set_slice(Container &container, index_type from
                          , index_type to, const data_type &v)
    {
        if (from > to) { return; }

        while (from < to) { container[from++] = v; }
    }

    template <class Iter>
    static void set_slice(Container &container, index_type from
                          , index_type to, Iter first, Iter)
    {
        if (from > to) { return; }

        // Populate range with other range.
        while (from < to) { container[from++] = *first++; }
    }

    static void delete_item(Container &container, index_type i) {
        set_item(container, i, data_type());
    }

    static void
    delete_slice(Container &container, index_type from, index_type to) {
        set_slice(container, from, to, {});
    }

    static size_t size(Container &container) {
        return container.size();
    }

    static bool contains(Container &container, const key_type &key) {
        return (std::find(container.begin(), container.end(), key)
                != container.end());
    }

    static index_type  get_min_index(Container&) {
        return 0;
    }

    static index_type get_max_index(Container &container) {
        return container.size();
    }

    static bool compare_index(Container&, index_type a, index_type b) {
        return a < b;
    }

    static index_type convert_index(Container &container, ::PyObject *i_)
    {
        boost::python::extract<long> i(i_);
        if (i.check()) {
            long index = i();
            if (index < 0)
                index += DerivedPolicies::size(container);
            if (index >= long(container.size()) || index < 0) {
                ::PyErr_SetString(PyExc_IndexError, "Index out of range");
                boost::python::throw_error_already_set();
            }
            return index;
        }

        ::PyErr_SetString(PyExc_TypeError, "Invalid index type");
        boost::python::throw_error_already_set();
        return index_type();
    }

private:
    static void base_append(Container &container, boost::python::object v) {
        boost::python::extract<data_type&> elem(v);
        // try if elem is an exact Data
        if (elem.check()) {
            DerivedPolicies::append(container, elem());
        } else {
            //  try to convert elem to data_type
            boost::python::extract<data_type> elem(v);
            if (elem.check()) {
                DerivedPolicies::append(container, elem());
            } else {
                ::PyErr_SetString(PyExc_TypeError,
                                  "Attempting to append an invalid type");
                boost::python::throw_error_already_set();
            }
        }
    }

    static void base_extend(Container &container, boost::python::object v) {
        std::vector<data_type> temp;
        boost::python::container_utils::extend_container(temp, v);
        DerivedPolicies::extend(container, temp.begin(), temp.end());
    }
};

} // namespace pysupport

#endif // pysupport_array_hpp_included_
